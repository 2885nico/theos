# 1. Preparing to read from the hard hisk.
## 1.1. PCI IDE Controller
- IDE refers to the electrical specification of cables which connect ATA drives to a device.
- IDE allows up to four disks to be connected.
- There are four types of disks:
	- ATA (Serial): known as SATA; used by modern hard drives.
	- ATA (Parallel): known as PATA; used by hard drives.
	- ATAPI (Serial): Used by modern optical drives.
	- ATAPI (Parallel): Commonly used by optical drives.
- We don't care if the drive is serial or parallel.
## 1.2. Possible IDE Drive Types
- Primary Master Drive.
- Primary Slave Drive.
- Secondary Master Drive.
- Secondary Slave Drive.

We'll be using the I/O operations we've implemented in the past to be able to read the disk sectors.

# 2. Reading from the disk with the ATA Controller.
Let's see the implementation of the LBA driver we made in Assembly in our `boot.asm` file but in C.
## 2.1. `disk.c`
### 2.1.1. `int disk_read_sector(int lba, int total, void* buffer)`
```
int disk_read_sector(int lba, int total, void* buffer)
{
        outb(0x1F6, (lba >> 24) | 0xE0);
        outb(0x1F2, total);
        outb(0x1F3, (unsigned char)(lba & 0xff));
        outb(0x1F4, (unsigned char) lba >> 8);
        outb(0x1F4, (unsigned char) lba >> 16);
        outb(0x1F7, 0x20);

        unsigned short* ptr = (unsigned short*) buffer;

        for (int b = 0; b < total; b++)
        {
                char c = insb(0x1F7);
                while(!(c & 0x08))
                {
                        c = insb(0x1F7);
                }
                // copy from hdd to memory
                for (int i = 0; i < 256; i++)
                {
                        *ptr = insw(0x1F0);
                        ptr++;
                }
        }
        return 0;
}
```
- `int disk_read_sector(int lba, int total, void* buffer)`: function definition. this might look very familiar. check out the `load32` and `ata_lba_read` labels in the `boot.asm` file. here, we're taking an `lba` (disk sector) initial sector (from), a `total` of sectors to read (up to) and a `buffer` in which we'll store the bytes read.
- `        outb(0x1F6, (lba >> 24) | 0xE0);`: here we right shuffle `lba` by 24 bits and `OR` it with `0xE0` and sending this data to the `0x1F6` I/O port.
	- if you look at `boot.asm`, the lines 73 to 76 might be familiar. this is because we're doing exactly that but in C.
- `        outb(0x1F2, total);`: here we send the total amount of sectors to read into the `0x1F2` I/O port.
- `        outb(0x1F3, (unsigned char)(lba & 0xff));`: in here we're sending the lower 8 bits to the `0x1F3` port. check the LBA ATA misc notes for info on this bitwise operation.
- `        outb(0x1F4, (unsigned char) lba >> 8);`: Here we send the `lba` right shifted by 8 to the `0x1F4` port.
- `        outb(0x1F4, (unsigned char) lba >> 16);`: And here we send the `lba` right shifted by 16 to the `0x1F4` port.
- `        outb(0x1F7, 0x20);`: And now we set the command port `0x1F7` to `0x20` or the read sector command.
- `        unsigned short* ptr = (unsigned short*) buffer;`: here we make a pointer to the buffer passed onto us by the caller. we need to cast it to be able to assign stuff to it.
- `        for (int b = 0; b < total; b++)`: here we start a loop. we'll read `total` amount of bytes into the `ptr` buffer pointer.
- `                char c = insb(0x1F7);`: here we read from the `0x1F7` port. we're expecting for...
- `                while(!(c & 0x08))`: bit 0x08. this bit is sent to us by the LBA drive and tells us that it's ready to send the data.
- `                        c = insb(0x1F7);`: here we continue to read and check if the `0x08` bit is set.
- `                for (int i = 0; i < 256; i++)`: if the `0x08` bit is set we go into the reading loop.
- `                        *ptr = insw(0x1F0);`: here we read two bytes into the `*ptr`.
- `                        ptr++;`: and we increment the pointer until `i` is higher than 256.
- `        return 0;`: and we return!

If you didn't understand the code, I wholeheartedly recommed you reading on the `boot.asm` code again on the 3-PROTECTEDMODE page. It'll help you understand this code better.

## 2.2 `disk.h`
For now, we just publish the function in the header file.
```
#ifndef DISK_H
#define DISK_H

int disk_read_sector(int lba, int total, void* buffer);

#endif 
```
# 3. Implementing a disk driver.
Now, what we have already made will help us abstract more things. For example, we can give the programmer an interface to select a drive and read an amount of bytes from it. For now, we'll only have drive zero, but we'll fix that when the time is right.
## 3.1. `disk.h`
We've made some changes to the `disk.h` file. Mainly, we've created some constants and a struct to help us with our drives.
```
typedef unsigned int PEACHOS_DISK_TYPE;

// real physical disk
#define PEACHOS_DISK_TYPE_REAL 0

struct disk
{
        PEACHOS_DISK_TYPE type;
        int sector_size;
};

int disk_read_block(struct disk* idisk, unsigned int lba, int total, void* buf);
struct disk* disk_get(int index);
void disk_search_and_init();
```
- `typedef unsigned int PEACHOS_DISK_TYPE;`: here we create a type definition of `unsigned int` to a DISK_TYPE. it could be a drive, a partition, or something else.
- `#define PEACHOS_DISK_TYPE_REAL 0`: here we define one of our disk types.
- `struct disk`: here we'll create a disk structure that will help us create information and attributes to our disks. for now, it'll be quite simple.
- `        PEACHOS_DISK_TYPE type;`: including its type and...
- `        int sector_size;`: it's sector size.
- `int disk_read_block(struct disk* idisk, unsigned int lba, int total, void* buf);`: function defintion. we'll see this later!
- `struct disk* disk_get(int index);`: function defintion. we'll see this later!
- `void disk_search_and_init();`: function defintion. we'll see this later!
## 3.2. `disk.c`
We've written three functions that will help us abstract the code and make our code more flexible. Let's go over them one by one.
### 3.2.1. `void disk_search_and_init()`
```
struct disk disk;
void disk_search_and_init()
{
        memset(&disk, 0, sizeof(disk));
        disk.type = PEACHOS_DISK_TYPE_REAL;
        disk.sector_size = PEACHOS_SECTOR_SIZE;
}
```
- `struct disk disk;`: we create a structure in which we'll save our disk data.
- `void disk_search_and_init()`: this function will initialize our disks and disk structures.
- `        memset(&disk, 0, sizeof(disk));`: here we zero out the structure.
- `        disk.type = PEACHOS_DISK_TYPE_REAL;`: here we assign a disk type of `PECHOS_DISK_TYPE_REAL`.
- `        disk.sector_size = PEACHOS_SECTOR_SIZE;`: and here we assign the sector size. we haven't seen this constant definition, but know that it is 512.
Pretty simple code! Let's continue.
### 3.2.2. `struct disk* disk_get(int index)`
```
struct disk* disk_get(int index)
{
        if(index != 0)
        {
                return 0;
        }
        return &disk;
}
```
- `struct disk* disk_get(int index)`: here we take a disk index. we're only working with disk ID 0, so it'll just return the disk for now.
- `        if(index != 0)`: here we check if `index` is not zero.
- `                return 0;`: if it's not zero, return 0 as any non zero index is invalid.
- `        return &disk;`: and return a pointer to the disk.
### 3.2.3. `int disk_read_block(struct disk* idisk, unsigned int lba, int total, void* buf)`
```
int disk_read_block(struct disk* idisk, unsigned int lba, int total, void* buf)
{
        if(idisk != &disk)
        {
                return -EIO;
        }
        return disk_read_sector(lba, total, buf);
}
```
- `int disk_read_block(struct disk* idisk, unsigned int lba, int total, void* buf)`: this function will be the new way in which programmers will access the disks. it'll take a disk, an `lba` starting block, a `total` amount of sectors to read and a `buf` in which we'll store the data read.
- `        if(idisk != &disk)`: here we check if the `idisk` is not the same as the disk we already have. this is for testing purposes and will be changed in the future.
- `                return -EIO;`: if not &disk, then return `-EIO`
- `        return disk_read_sector(lba, total, buf);`: and return the read sectors using the already available `disk_read_sector`.
As you can see, we'll now use the `disk_read_block` function directly instead of calling the `disk_read_sector`. 
## 3.3. `config.h`
We've also defined some new constants in our `config.h` file.
```
#define PEACHOS_SECTOR_SIZE             512
```
It's just the sector size. That's it for now!
